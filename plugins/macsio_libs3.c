#include <libs3.h>
#include <json-cwx/json.h>

#include <macsio_clargs.h>
#include <macsio_iface.h>
#include <macsio_log.h>
#include <macsio_main.h>
#include <macsio_mif.h>
#include <macsio_utils.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#ifdef HAVE_MPI

#include <mpi.h>

#endif

/*!
\defgroup plugins Plugins
@{
*/

/*!
\addtogroup MIF Template
\brief A simple MIF Plugin Template
@{
*/

static char const *iface_name = "libs3"; /**< Name of the interface this plugin uses */
static char const *iface_ext = "dat";    /**< Default file extension for files generated by this plugin */
// static int json_as_html = 0;             /**< Use HTML output instead of raw ascii */
// static int my_opt_one;                   /**< Example of a static scope, plugin-specific variable to be set in
//                                                process_args to control plugin behavior */
// static int my_opt_two;                   /**< Another example variable to control plugin behavior */
// static char *my_opt_three_string;        /**< Another example variable to control plugin behavior */
// static float my_opt_three_float;         /**< Another example variable to control plugin behavior */

/*!
\brief Process command-line arguments specific to this plugin

Uses MACSIO_CLARGS_ProcessCmdline() to do its work.

This example plugin is implemented to route command line arguments to memory locations
(e.g. static variables) here in the plugin.  Alternatively, a plugin can choose to
route the results of MACSIO_CLARGS_ProcessCmdline() to a JSON object. MACSio's main is
implemented that way.
*/

static char *access_key = NULL;
static char *secret_key = NULL;
static char *host = NULL;
static char *auth_region = NULL;
static char *sample_bucket = NULL;

static int process_args(
    int argi,    /**< [in] Argument index of first argument that is specific to this plugin */
    int argc,    /**< [in] argc as passed into main */
    char *argv[] /**< [in] argv as passed into main */
)
{
    /* Can use MACSIO_CLARGS_TOJSON here instead in which case pass the pointer to
       a json_object* as first arg and eliminate all the pointers to specific
       variables. The args will be returned as a json-c object. */
    const MACSIO_CLARGS_ArgvFlags_t argFlags = {MACSIO_CLARGS_WARN, MACSIO_CLARGS_TOMEM, MACSIO_CLARGS_ASSIGN_ON};

    MACSIO_CLARGS_ProcessCmdline(0, argFlags, argi, argc, argv,
                                 "--s3_host %s", "cirrus-s3.epcc.ed.ac.uk", "S3 Host", &host,
                                 "--s3_access_key %s", MACSIO_CLARGS_NODEFAULT, "S3 Access key", &access_key,
                                 "--s3_secret_key %s", MACSIO_CLARGS_NODEFAULT, "S3 Secret ket", &secret_key,
                                 "--s3_region %s", "uk-cirrus-1", "S3 Auth region", &auth_region,
                                 "--s3_bucket %s", MACSIO_CLARGS_NODEFAULT, "S3 Bucket", &sample_bucket,
                                 //  "--json_as_html", "",
                                 //  "Write files as HTML instead of raw ascii [false]",
                                 //  &json_as_html,
                                 //  "--my_opt_one", "",
                                 //  "Help message for my_opt_one which has no arguments. If present, local\n"
                                 //  "var my_opt_one will be assigned a value of 1 and a value of zero otherwise.",
                                 //  &my_opt_one,
                                 //  "--my_opt_two %d", MACSIO_CLARGS_NODEFAULT,
                                 //  "Help message for my_opt_two which has a single integer argument",
                                 //  &my_opt_two,
                                 //  "--my_opt_three %s %f", MACSIO_CLARGS_NODEFAULT,
                                 //  "Help message for my_opt_three which has a string argument and a float argument",
                                 //  &my_opt_three_string, &my_opt_three_float,
                                 MACSIO_CLARGS_END_OF_ARGS);

    // Read environment variables later, so they have a higher priority
    char *p = NULL;
    p = getenv("S3_ACCESS_KEY");
    if (p != NULL) access_key = p;
    p = getenv("S3_SECRET_KEY");
    if (p != NULL) secret_key = p;
    p = getenv("S3_HOST");
    if (p != NULL) host = p;
    p = getenv("S3_REGION");
    if (p != NULL) auth_region = p;
    p = getenv("S3_BUCKET");
    if (p != NULL) sample_bucket = p;

    return 0;
}

/*!
\brief CreateFile MIF Callback

This implments the MACSIO_MIF_CreateFile callback needed for a MIF mode plugin.

\return A void pointer to the plugin-specific file handle
*/
static void *CreateMyFile(
    const char *fname,  /**< [in] Name of the MIF file to create */
    const char *nsname, /**< [in] Name of the namespace within the file for caller should use. */
    void *userData      /**< [in] Optional plugin-specific user-defined data */
)
{
    FILE *file = fopen(fname, "w");
    return (void *)file;
}

/*!
\brief OpenFile MIF Callback

This implments the MACSIO_MIF_OpenFile callback needed for a MIF mode plugin.

\return A void pointer to the plugin-specific file handle
*/
static void *OpenMyFile(
    const char *fname,            /**< [in] Name of the MIF file to open */
    const char *nsname,           /**< [in] Name of the namespace within the file caller should use */
    MACSIO_MIF_ioFlags_t ioFlags, /**< [in] Various flags indicating behavior/options */
    void *userData                /**< [in] Optional plugin-specific user-defined data */
)
{
    FILE *file = fopen(fname, "a+");
    return (void *)file;
}

/*!
\brief CloseFile MIF Callback

This implments the MACSIO_CloseFile callback needed for a MIF mode plugin.
*/
static int CloseMyFile(
    void *file,    /**< [in] A void pointer to the plugin specific file handle */
    void *userData /**< [in] Optional plugin specific user-defined data */
)
{
    return fclose((FILE *)file);
}

/*
libs3 related functions
*/
static S3Status responsePropertiesCallback(
    const S3ResponseProperties *properties,
    void *callbackData)
{
    // printf("responsePropertiesCallback\n");
    return S3StatusOK;
}

static void responseCompleteCallback(
    S3Status status,
    const S3ErrorDetails *error,
    void *callbackData)
{
    // printf(">>>> responseCompleteCallback(): %s\n", error->message);
    return;
}

static const S3ResponseHandler responseHandler = {
    &responsePropertiesCallback,
    &responseCompleteCallback};

/*!
\brief Write a single mesh part to a MIF file

All this method does is serialize the JSON object for the given mesh
part to an ASCII string and then appends/writes that string at the
end of the current file.

After serializing the object to an ASCII string and writing it to the
file, the memory for the ASCII string is released by json_object_free_printbuf().

\return A tiny JSON object holding the name of the file, the offset at
which the JSON object for this part was written in the file and the part's ID.
*/
typedef struct put_object_callback_data
{
    const char *dataStr;
    uint64_t contentLength;
} put_object_callback_data;

static int putObjectDataCallback(int bufferSize, char *buffer, void *callbackData)
{
    put_object_callback_data *data = (put_object_callback_data *)callbackData;

    int ret = 0;

    if (data->contentLength)
    {
        // int toRead = ((data->contentLength > (unsigned)bufferSize) ? (unsigned)bufferSize : data->contentLength);
        // ret = fread(buffer, 1, toRead, data->infile);

        if (data->contentLength >= bufferSize)
        {
            memcpy(buffer, data->dataStr, bufferSize);
            ret = bufferSize;
        }
        else
        {
            memcpy(buffer, data->dataStr, data->contentLength);
            ret = data->contentLength;
        }
    }
    data->contentLength -= ret;
    printf("contentLength: %d\n", data->contentLength);
    return ret;
}

// #include <sys/stat.h>
static json_object *write_mesh_part(
    FILE *myFile,         /**< [in] The file handle being used in a MIF dump */
    char *fileName,       /**< [in] Name of the MIF file */
    json_object *part_obj /**< [in] The json object representing this mesh part */
)
{
    put_object_callback_data data;
    // struct stat statbuf;
    const char sample_key[] = "hello.txt";
    const char sample_file[] = "resource/hello.txt";

    // if (stat(sample_file, &statbuf) == -1)
    // {
    //     fprintf(stderr, "\nERROR: Failed to stat file %s: ", sample_file);
    //     perror(0);
    //     exit(-1);
    // }

    // int contentLength = statbuf.st_size;
    // data.contentLength = contentLength;

    // if (!(data.infile = fopen(sample_file, "r")))
    // {
    //     fprintf(stderr, "\nERROR: Failed to open input file %s: ", sample_file);
    //     perror(0);
    //     exit(-1);
    // }

    S3PutObjectHandler putObjectHandler =
        {
            responseHandler,
            &putObjectDataCallback};

    // fclose(data.infile);

    json_object *part_info = json_object_new_object();

    //#warning SOMEHOW SHOULD INCLUDE OFFSETS TO EACH VARIABLE
    /* Write the json mesh part object as an ascii string */
    // fprintf(myFile, "%s\n", json_object_to_json_string_ext(part_obj, JSON_C_TO_STRING_PRETTY));
    data.dataStr = json_object_to_json_string_ext(part_obj, JSON_C_TO_STRING_PRETTY);
    int contentLength = strlen(data.dataStr);
    data.contentLength = contentLength;

    const S3BucketContext bucketContext = {
        host,
        sample_bucket,
        S3ProtocolHTTPS,
        S3UriStylePath,
        access_key,
        secret_key,
        NULL,
        auth_region};

    S3_put_object(&bucketContext, fileName, contentLength, NULL, NULL, 0, &putObjectHandler, &data);

    printf(">>>> S3_put_object() finished \n");
    json_object_free_printbuf(part_obj);

    /* Form the return 'value' holding the information on where to find this part */
    json_object_object_add(part_info, "partid",
                           //#warning CHANGE NAME OF KEY IN JSON TO PartID
                           json_object_new_int(json_object_path_get_int(part_obj, "Mesh/ChunkID")));
    json_object_object_add(part_info, "file",
                           json_object_new_string(fileName));
    json_object_object_add(part_info, "offset",
                           json_object_new_double((double)ftello(myFile)));

    return part_info;
}

/*!
\brief Main MIF dump implementation for this plugin

This is the function MACSio main calls to do the actual dump of data with this plugin.

It uses \ref MACSIO_MIF twice; once for the main dump and a second time to create the
root (or master) file. However, in the second use, the file count is set to 1. That
means that the root file is effectively written using serial (e.g. non-parallel) I/O.

It is a useful exercise to ask how we might improve the implementation here to avoid
writing the root file using serial I/O.
*/
static void main_dump(
    int argi,              /**< [in] Command-line argument index at which first plugin-specific arg appears */
    int argc,              /**< [in] argc from main */
    char **argv,           /**< [in] argv from main */
    json_object *main_obj, /**< [in] The main json object representing all data to be dumped */
    int dumpn,             /**< [in] The number/index of this dump. Each dump in a sequence gets a unique,
                                      monotone increasing index starting from 0 */
    double dumpt           /**< [in] The time to be associated with this dump (like a simulation's time) */
)
{
    int i, rank, numFiles;
    char fileName[256];
    FILE *myFile;
    MACSIO_MIF_ioFlags_t ioFlags = {MACSIO_MIF_WRITE, (unsigned int)JsonGetInt(main_obj, "clargs/exercise_scr") & 0x1};
    MACSIO_MIF_baton_t *bat;
    json_object *parts;
    // json_object *part_infos = json_object_new_array();

    /* process cl args */
    process_args(argi, argc, argv);

    printf("host=%s\nauth_region=%s\naccess_key=%s\nsecret_key=%s\nsample_bucket=%s\n", host, auth_region, access_key, secret_key, sample_bucket);

    /* ensure we're in MIF mode and determine the file count */
    //#warning SIMPLIFY THIS LOGIC USING NEW JSON INTERFACE
    json_object *parfmode_obj = json_object_path_get_array(main_obj, "clargs/parallel_file_mode");
    if (parfmode_obj)
    {
        json_object *modestr = json_object_array_get_idx(parfmode_obj, 0);
        json_object *filecnt = json_object_array_get_idx(parfmode_obj, 1);
        if (!strcmp(json_object_get_string(modestr), "SIF"))
        {
            MACSIO_LOG_MSG(Die, ("libs3 plugin cannot currently handle SIF mode"));
        }
        else
        {
            numFiles = json_object_get_int(filecnt);
        }
    }
    else
    {
        char const *modestr = json_object_path_get_string(main_obj, "clargs/parallel_file_mode");
        if (!strcmp(modestr, "SIF"))
        {
            MACSIO_LOG_MSG(Die, ("libs3 plugin cannot currently handle SIF mode"));
        }
        else if (!strcmp(modestr, "MIFMAX"))
            numFiles = json_object_path_get_int(main_obj, "parallel/mpi_size");
        else if (!strcmp(modestr, "MIFAUTO"))
        {
            /* Call MACSio utility to determine optimal file count */
        }
    }

    S3Status status = S3_initialize(NULL, S3_INIT_ALL, host);
    bat = MACSIO_MIF_Init(numFiles, ioFlags, MACSIO_MAIN_Comm, 3,
                          CreateMyFile, OpenMyFile, CloseMyFile, 0);

    rank = json_object_path_get_int(main_obj, "parallel/mpi_rank");

    /* Construct name for the data */
    sprintf(fileName, "%s_libs3_%05d_%03d.%s",
            json_object_path_get_string(main_obj, "clargs/filebase"),
            MACSIO_MIF_RankOfGroup(bat, rank),
            dumpn,
            json_object_path_get_string(main_obj, "clargs/fileext"));

    MACSIO_UTILS_RecordOutputFiles(dumpn, fileName);

    myFile = (FILE *)MACSIO_MIF_WaitForBaton(bat, fileName, 0);

    parts = json_object_path_get_array(main_obj, "problem/parts");
    for (i = 0; i < json_object_array_length(parts); i++)
    {
        json_object *this_part = json_object_array_get_idx(parts, i);
        write_mesh_part(myFile, fileName, this_part);
        // json_object_array_add(part_infos, write_mesh_part(myFile, fileName, this_part));
    }

    /* Hand off the baton to the next processor. This winds up closing
     * the file so that the next processor that opens it can be assured
     * of getting a consistent and up to date view of the file's contents. */
    MACSIO_MIF_HandOffBaton(bat, myFile);

    /* We're done using MACSIO_MIF for these files, so finish it off */
    MACSIO_MIF_Finish(bat);
    S3_deinitialize();

    /* Use MACSIO_MIF a second time to manage writing of the master/root
       file contents. This winds up being serial I/O but also means we
       never collect all info on all parts to any single processor. */
    //#warning THERE IS A BETTER WAY TO DO USING LOOP OF NON-BLOCKING RECIEVES
    // bat = MACSIO_MIF_Init(1, ioFlags, MACSIO_MAIN_Comm, 5,
    //                       CreateMyFile, OpenMyFile, CloseMyFile, 0);

    // /* Construct name for the silo file */
    // sprintf(fileName, "%s_libs3_root_%03d.%s",
    //         json_object_path_get_string(main_obj, "clargs/filebase"),
    //         dumpn,
    //         json_object_path_get_string(main_obj, "clargs/fileext"));

    // MACSIO_UTILS_RecordOutputFiles(dumpn, fileName);

    // /* Wait for MACSIO_MIF to give this processor exclusive access */
    // myFile = (FILE *)MACSIO_MIF_WaitForBaton(bat, fileName, 0);

    // //#warning FIX THE STRING THAT WE PRODUCE HERE SO ITS A SINGLE JSON ARRAY OBJECT
    // /* This processor's work on the file is just to write its part_infos */
    // fprintf(myFile, "%s\n", json_object_to_json_string_ext(part_infos, JSON_C_TO_STRING_PRETTY));

    // MACSIO_MIF_HandOffBaton(bat, myFile);

    // MACSIO_MIF_Finish(bat);

    /* decriment ref-count (and free) part_infos */
    // json_object_put(part_infos);
}

/*!
\brief Method to register this plugin with MACSio main

Due to its use to initialize a file-scope, static const variable, this
function winds up being called at load time (e.g. before main is even called).

Its purpose is to add key information about this plugin to MACSio's global
interface table.
*/
static int register_this_interface()
{
    MACSIO_IFACE_Handle_t iface;

    if (strlen(iface_name) >= MACSIO_IFACE_MAX_NAME)
        MACSIO_LOG_MSG(Die, ("Interface name \"%s\" too long", iface_name));

    /* Populate information about this plugin */
    strcpy(iface.name, iface_name);
    strcpy(iface.ext, iface_ext);
    iface.dumpFunc = main_dump;
    iface.processArgsFunc = process_args;

    /* Register this plugin */
    if (!MACSIO_IFACE_Register(&iface))
        MACSIO_LOG_MSG(Die, ("Failed to register interface \"%s\"", iface_name));

    return 0;
}

/*!
\brief Dummy initializer to trigger register_this_interface by the loader

This one statement is the only statement requiring compilation by
a C++ compiler. That is because it involves initialization and non
constant expressions (a function call in this case). This function
call is guaranteed to occur during *initialization* (that is before
even 'main' is called) and so will have the effect of populating the
iface_map array merely by virtue of the fact that this code is linked
with a main.
*/
static int const dummy = register_this_interface();

/*!@}*/

/*!@}*/
