#include <libs3.h>
#include <json-cwx/json.h>

#include <macsio_clargs.h>
#include <macsio_iface.h>
#include <macsio_log.h>
#include <macsio_main.h>
#include <macsio_mif.h>
#include <macsio_utils.h>
#include <macsio_timing.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#ifdef HAVE_MPI

#include <mpi.h>

#endif

/*!
\defgroup plugins Plugins
@{
*/

/*!
\addtogroup Libs3 Plugin
\brief A MIF Plugin for Object Store Backend
@{
*/

static char const *iface_name = "libs3"; /**< Name of the interface this plugin uses */
static char const *iface_ext = "dat";    /**< Default file extension for files generated by this plugin */

// All necessary parameters for the S3 API
static char *access_key = NULL;
static char *secret_key = NULL;
static char *host = NULL;
static char *auth_region = NULL;
static char *sample_bucket = NULL;

/*!
\brief Process command-line arguments specific to this plugin

Uses MACSIO_CLARGS_ProcessCmdline() to do its work.

Also will read environment variables (higher priority)
*/
static int process_args(
    int argi,    /**< [in] Argument index of first argument that is specific to this plugin */
    int argc,    /**< [in] argc as passed into main */
    char *argv[] /**< [in] argv as passed into main */
)
{
    /* Can use MACSIO_CLARGS_TOJSON here instead in which case pass the pointer to
       a json_object* as first arg and eliminate all the pointers to specific
       variables. The args will be returned as a json-c object. */
    const MACSIO_CLARGS_ArgvFlags_t argFlags = {MACSIO_CLARGS_WARN, MACSIO_CLARGS_TOMEM};

    MACSIO_CLARGS_ProcessCmdline(0, argFlags, argi, argc, argv,
                                 "--s3_host %s", "cirrus-s3.epcc.ed.ac.uk", "S3 Host", &host,
                                 "--s3_access_key %s", MACSIO_CLARGS_NODEFAULT, "S3 Access key", &access_key,
                                 "--s3_secret_key %s", MACSIO_CLARGS_NODEFAULT, "S3 Secret ket", &secret_key,
                                 "--s3_region %s", "uk-cirrus-1", "S3 Auth region", &auth_region,
                                 "--s3_bucket %s", MACSIO_CLARGS_NODEFAULT, "S3 Bucket", &sample_bucket,
                                 MACSIO_CLARGS_END_OF_ARGS);

    // Read environment variables later, so they have a higher priority
    char *p = NULL;
    p = getenv("S3_ACCESS_KEY");
    if (p != NULL)
        access_key = p;
    p = getenv("S3_SECRET_KEY");
    if (p != NULL)
        secret_key = p;
    p = getenv("S3_HOST");
    if (p != NULL)
        host = p;
    p = getenv("S3_REGION");
    if (p != NULL)
        auth_region = p;
    p = getenv("S3_BUCKET");
    if (p != NULL)
        sample_bucket = p;

    return 0;
}

/*!
\brief CreateFile MIF Callback

This implments the MACSIO_MIF_CreateFile callback needed for a MIF mode plugin.

\return A void pointer to the plugin-specific file handle
*/
static void *CreateMyFile(
    const char *fname,  /**< [in] Name of the MIF file to create */
    const char *nsname, /**< [in] Name of the namespace within the file for caller should use. */
    void *userData      /**< [in] Optional plugin-specific user-defined data */
)
{
    // FILE *file = fopen(fname, "w");
    // return (void *)file;
    return NULL;
}

/*!
\brief OpenFile MIF Callback

This implments the MACSIO_MIF_OpenFile callback needed for a MIF mode plugin.

\return A void pointer to the plugin-specific file handle
*/
static void *OpenMyFile(
    const char *fname,            /**< [in] Name of the MIF file to open */
    const char *nsname,           /**< [in] Name of the namespace within the file caller should use */
    MACSIO_MIF_ioFlags_t ioFlags, /**< [in] Various flags indicating behavior/options */
    void *userData                /**< [in] Optional plugin-specific user-defined data */
)
{
    // FILE *file = fopen(fname, "a+");
    // return (void *)file;
    return NULL;
}

/*!
\brief CloseFile MIF Callback

This implments the MACSIO_CloseFile callback needed for a MIF mode plugin.
*/
static int CloseMyFile(
    void *file,    /**< [in] A void pointer to the plugin specific file handle */
    void *userData /**< [in] Optional plugin specific user-defined data */
)
{
    // return fclose((FILE *)file);
    return 0;
}

/*
libs3 related functions
*/
static S3Status responsePropertiesCallback(
    const S3ResponseProperties *properties,
    void *callbackData)
{
    // printf("responsePropertiesCallback\n");
    return S3StatusOK;
}

static void responseCompleteCallback(
    S3Status status,
    const S3ErrorDetails *error,
    void *callbackData)
{
    // printf(">>>> responseCompleteCallback(): %s\n", error->message);
    return;
}

static const S3ResponseHandler responseHandler = {
    &responsePropertiesCallback,
    &responseCompleteCallback};

/*!
\brief Write a single mesh part to a MIF file

All this method does is serialize the JSON object for the given mesh
part to an ASCII string and then appends/writes that string at the
end of the current file.

After serializing the object to an ASCII string and writing it to the
file, the memory for the ASCII string is released by json_object_free_printbuf().

\return A tiny JSON object holding the name of the file, the offset at
which the JSON object for this part was written in the file and the part's ID.
*/
typedef struct put_object_callback_data
{
    const char *dataStr;
    uint64_t contentLength;
} put_object_callback_data;

static int putObjectDataCallback(int bufferSize, char *buffer, void *callbackData)
{
    put_object_callback_data *data = (put_object_callback_data *)callbackData;

    int ret = 0;

    if (data->contentLength)
    {
        // int toRead = ((data->contentLength > (unsigned)bufferSize) ? (unsigned)bufferSize : data->contentLength);
        // ret = fread(buffer, 1, toRead, data->infile);

        if (data->contentLength >= bufferSize)
        {
            memcpy(buffer, data->dataStr, bufferSize);
            ret = bufferSize;
        }
        else
        {
            memcpy(buffer, data->dataStr, data->contentLength);
            ret = data->contentLength;
        }
    }
    data->contentLength -= ret;
    printf("contentLength: %d\n", data->contentLength);
    return ret;
}

static void write_mesh_part(
    FILE *myFile,         /**< [in] The file handle being used in a MIF dump */
    char *fileName,       /**< [in] Name of the MIF file */
    json_object *part_obj, /**< [in] The json object representing this mesh part */
    int dumpn
)
{
    MACSIO_TIMING_GroupMask_t write_s3_mif_grp = MACSIO_TIMING_GroupMask("write_s3_mif");
    MACSIO_TIMING_TimerId_t write_s3_mif_tid;
    double timer_dt;
    put_object_callback_data data;

    S3PutObjectHandler putObjectHandler =
        {
            responseHandler,
            &putObjectDataCallback};

    //#warning SOMEHOW SHOULD INCLUDE OFFSETS TO EACH VARIABLE
    /* Write the json mesh part object as an ascii string */
    data.dataStr = json_object_to_json_string_ext(part_obj, JSON_C_TO_STRING_PLAIN);
    int contentLength = strlen(data.dataStr);
    data.contentLength = contentLength;

    const S3BucketContext bucketContext = {
        host,
        sample_bucket,
        S3ProtocolHTTPS,
        S3UriStylePath,
        access_key,
        secret_key,
        NULL,
        auth_region};

    write_s3_mif_grp = MT_StartTimer("write_s3_mif", write_s3_mif_grp, dumpn);
    S3_put_object(&bucketContext, fileName, contentLength, NULL, NULL, 0, &putObjectHandler, &data);
    timer_dt = MT_StopTimer(write_s3_mif_tid);

    printf(">>>> S3_put_object() finished \n");
    json_object_free_printbuf(part_obj);
}

/*!
\brief Main MIF dump implementation for this plugin

This is the function MACSio main calls to do the actual dump of data with this plugin.

It uses \ref MACSIO_MIF twice; once for the main dump and a second time to create the
root (or master) file. However, in the second use, the file count is set to 1. That
means that the root file is effectively written using serial (e.g. non-parallel) I/O.

It is a useful exercise to ask how we might improve the implementation here to avoid
writing the root file using serial I/O.
*/
static void main_dump(
    int argi,              /**< [in] Command-line argument index at which first plugin-specific arg appears */
    int argc,              /**< [in] argc from main */
    char **argv,           /**< [in] argv from main */
    json_object *main_obj, /**< [in] The main json object representing all data to be dumped */
    int dumpn,             /**< [in] The number/index of this dump. Each dump in a sequence gets a unique,
                                      monotone increasing index starting from 0 */
    double dumpt           /**< [in] The time to be associated with this dump (like a simulation's time) */
)
{
    int i, rank, numFiles;
    char fileName[256];
    FILE *myFile;
    MACSIO_MIF_ioFlags_t ioFlags = {MACSIO_MIF_WRITE, (unsigned int)JsonGetInt(main_obj, "clargs/exercise_scr") & 0x1};
    MACSIO_MIF_baton_t *bat;
    json_object *parts;

    MACSIO_TIMING_GroupMask_t main_dump_mif_grp = MACSIO_TIMING_GroupMask("main_dump_mif");
    MACSIO_TIMING_TimerId_t main_dump_mif_tid;
    double timer_dt;

    /* process cl args */
    process_args(argi, argc, argv);

    printf("host=%s\nauth_region=%s\naccess_key=%s\nsecret_key=%s\nsample_bucket=%s\n", host, auth_region, access_key, secret_key, sample_bucket);

    /* ensure we're in MIF mode and determine the file count */
    //#warning SIMPLIFY THIS LOGIC USING NEW JSON INTERFACE
    json_object *parfmode_obj = json_object_path_get_array(main_obj, "clargs/parallel_file_mode");
    if (parfmode_obj)
    {
        json_object *modestr = json_object_array_get_idx(parfmode_obj, 0);
        json_object *filecnt = json_object_array_get_idx(parfmode_obj, 1);
        if (!strcmp(json_object_get_string(modestr), "SIF"))
        {
            MACSIO_LOG_MSG(Die, ("libs3 plugin cannot currently handle SIF mode"));
        }
        else
        {
            numFiles = json_object_get_int(filecnt);
        }
    }
    else
    {
        char const *modestr = json_object_path_get_string(main_obj, "clargs/parallel_file_mode");
        if (!strcmp(modestr, "SIF"))
        {
            MACSIO_LOG_MSG(Die, ("libs3 plugin cannot currently handle SIF mode"));
        }
        else if (!strcmp(modestr, "MIFMAX"))
            numFiles = json_object_path_get_int(main_obj, "parallel/mpi_size");
        else if (!strcmp(modestr, "MIFAUTO"))
        {
            /* Call MACSio utility to determine optimal file count */
        }
    }

    S3Status status = S3_initialize(NULL, S3_INIT_ALL, host);
    bat = MACSIO_MIF_Init(numFiles, ioFlags, MACSIO_MAIN_Comm, 3,
                          CreateMyFile, OpenMyFile, CloseMyFile, 0);

    rank = json_object_path_get_int(main_obj, "parallel/mpi_rank");

    /* Construct name for the data */
    sprintf(fileName, "%s_libs3_%05d_%03d.%s",
            json_object_path_get_string(main_obj, "clargs/filebase"),
            MACSIO_MIF_RankOfGroup(bat, rank),
            dumpn,
            json_object_path_get_string(main_obj, "clargs/fileext"));

    MACSIO_UTILS_RecordOutputFiles(dumpn, fileName);

    myFile = (FILE *)MACSIO_MIF_WaitForBaton(bat, fileName, 0);

    parts = json_object_path_get_array(main_obj, "problem/parts");
    for (i = 0; i < json_object_array_length(parts); i++)
    {
        json_object *this_part = json_object_array_get_idx(parts, i);
        write_mesh_part(myFile, fileName, this_part, dumpn);
    }

    /* Hand off the baton to the next processor. This winds up closing
     * the file so that the next processor that opens it can be assured
     * of getting a consistent and up to date view of the file's contents. */
    MACSIO_MIF_HandOffBaton(bat, myFile);

    /* We're done using MACSIO_MIF for these files, so finish it off */
    MACSIO_MIF_Finish(bat);
    S3_deinitialize();
}

/*!
\brief Method to register this plugin with MACSio main

Due to its use to initialize a file-scope, static const variable, this
function winds up being called at load time (e.g. before main is even called).

Its purpose is to add key information about this plugin to MACSio's global
interface table.
*/
static int register_this_interface()
{
    MACSIO_IFACE_Handle_t iface;

    if (strlen(iface_name) >= MACSIO_IFACE_MAX_NAME)
        MACSIO_LOG_MSG(Die, ("Interface name \"%s\" too long", iface_name));

    /* Populate information about this plugin */
    strcpy(iface.name, iface_name);
    strcpy(iface.ext, iface_ext);
    iface.dumpFunc = main_dump;
    iface.processArgsFunc = process_args;

    /* Register this plugin */
    if (!MACSIO_IFACE_Register(&iface))
        MACSIO_LOG_MSG(Die, ("Failed to register interface \"%s\"", iface_name));

    return 0;
}

/*!
\brief Dummy initializer to trigger register_this_interface by the loader

This one statement is the only statement requiring compilation by
a C++ compiler. That is because it involves initialization and non
constant expressions (a function call in this case). This function
call is guaranteed to occur during *initialization* (that is before
even 'main' is called) and so will have the effect of populating the
iface_map array merely by virtue of the fact that this code is linked
with a main.
*/
static int const dummy = register_this_interface();

/*!@}*/

/*!@}*/
